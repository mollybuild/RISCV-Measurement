#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create:
# Rationale
# dhry.h
# dhry_1.c
# dhry_2.c
# This archive created: Wed Jul 6 16:50:06 1988
export PATH; PATH=/bin:/usr/bin:$PATH
if test -f 'Rationale'
then
echo shar: "will not over-write existing file 'Rationale'"
else
sed 's/^X//' << \SHAR_EOF > 'Rationale'
XDhrystone Benchmark: Rationale for Version 2 and Measurement Rules
X
X Reinhold P. Weicker
X Siemens AG, E STE 35
X Postfach 3240
X D-8520 Erlangen
X Germany (West)
X
X
X
X
XThe Dhrystone benchmark program [1] has become a popular benchmark for
XCPU/compiler performance measurement, in particular in the area of
Xminicomputers, workstations, PC's and microprocesors. It apparently
Xsatisfies a need for an easy-to-use integer benchmark; it gives a first
Xperformance indication which is more meaningful than MIPS numbers
Xwhich, in their literal meaning (million instructions per second),
Xcannot be used across different instruction sets (e.g. RISC vs. CISC).
XWith the increasing use of the benchmark, it seems necessary to
Xreconsider the benchmark and to check whether it can still fulfill this
Xfunction. Version 2 of Dhrystone is the result of such a re-
Xevaluation, it has been made for two reasons:
X
Xo Dhrystone has been published in Ada [1], and Versions in Ada, Pascal
X and C have been distributed by Reinhold Weicker via floppy disk.
X However, the version that was used most often for benchmarking has
X been the version made by Rick Richardson by another translation from
X the Ada version into the C programming language, this has been the
X version distributed via the UNIX network Usenet [2].
X
X There is an obvious need for a common C version of Dhrystone, since C
X is at present the most popular system programming language for the
X class of systems (microcomputers, minicomputers, workstations) where
X Dhrystone is used most. There should be, as far as possible, only
X one C version of Dhrystone such that results can be compared without
X restrictions. In the past, the C versions distributed by Rick
X Richardson (Version 1.1) and by Reinhold Weicker had small (though
X not significant) differences.
X
X Together with the new C version, the Ada and Pascal versions have
X been updated as well.
X
Xo As far as it is possible without changes to the Dhrystone statistics,
X optimizing compilers should be prevented from removing significant
X statements. It has turned out in the past that optimizing compilers
X suppressed code generation for too many statements (by "dead code
X removal" or "dead variable elimination"). This has lead to the
X danger that benchmarking results obtained by a naive application of
X Dhrystone - without inspection of the code that was generated - could
X become meaningless.
X
XThe overall policiy for version 2 has been that the distribution of
Xstatements, operand types and operand locality described in [1] should
Xremain unchanged as much as possible. (Very few changes were
Xnecessary; their impact should be negligible.) Also, the order of
Xstatements should remain unchanged. Although I am aware of some
Xcritical remarks on the benchmark - I agree with several of them - and
Xknow some suggestions for improvement, I didn't want to change the
Xbenchmark into something different from what has become known as
X"Dhrystone"; the confusion generated by such a change would probably
Xoutweight the benefits. If I were to write a new benchmark program, I
Xwouldn't give it the name "Dhrystone" since this denotes the program
Xpublished in [1]. However, I do recognize the need for a larger number
Xof representative programs that can be used as benchmarks; users should
Xalways be encouraged to use more than just one benchmark.
X
XThe new versions (version 2.1 for C, Pascal and Ada) will be
Xdistributed as widely as possible. (Version 2.1 differs from version
X2.0 distributed via the UNIX Network Usenet in March 1988 only in a few
Xcorrections for minor deficiencies found by users of version 2.0.)
XReaders who want to use the benchmark for their own measurements can
Xobtain a copy in machine-readable form on floppy disk (MS-DOS or XENIX
Xformat) from the author.
X
X
XIn general, version 2 follows - in the parts that are significant for
Xperformance measurement, i.e. within the measurement loop - the
Xpublished (Ada) version and the C versions previously distributed.
XWhere the versions distributed by Rick Richardson [2] and Reinhold
XWeicker have been different, it follows the version distributed by
XReinhold Weicker. (However, the differences have been so small that
Xtheir impact on execution time in all likelihood has been negligible.)
XThe initialization and UNIX instrumentation part - which had been
Xomitted in [1] - follows mostly the ideas of Rick Richardson [2].
XHowever, any changes in the initialization part and in the printing of
Xthe result have no impact on performance measurement since they are
Xoutside the measaurement loop. As a concession to older compilers,
Xnames have been made unique within the first 8 characters for the C
Xversion.
X
XThe original publication of Dhrystone did not contain any statements
Xfor time measurement since they are necessarily system-dependent.
XHowever, it turned out that it is not enough just to inclose the main
Xprocedure of Dhrystone in a loop and to measure the execution time. If
Xthe variables that are computed are not used somehow, there is the
Xdanger that the compiler considers them as "dead variables" and
Xsuppresses code generation for a part of the statements. Therefore in
Xversion 2 all variables of "main" are printed at the end of the
Xprogram. This also permits some plausibility control for correct
Xexecution of the benchmark.
X
XAt several places in the benchmark, code has been added, but only in
Xbranches that are not executed. The intention is that optimizing
Xcompilers should be prevented from moving code out of the measurement
Xloop, or from removing code altogether. Statements that are executed
Xhave been changed in very few places only. In these cases, only the
Xrole of some operands has been changed, and it was made sure that the
Xnumbers defining the "Dhrystone distribution" (distribution of
Xstatements, operand types and locality) still hold as much as possible.
XExcept for sophisticated optimizing compilers, execution times for
Xversion 2.1 should be the same as for previous versions.
X
XBecause of the self-imposed limitation that the order and distribution
Xof the executed statements should not be changed, there are still cases
Xwhere optimizing compilers may not generate code for some statements.
XTo a certain degree, this is unavoidable for small synthetic
Xbenchmarks. Users of the benchmark are advised to check code listings
Xwhether code is generated for all statements of Dhrystone.
X
XContrary to the suggestion in the published paper and its realization
Xin the versions previously distributed, no attempt has been made to
Xsubtract the time for the measurement loop overhead. (This calculation
Xhas proven difficult to implement in a correct way, and its omission
Xmakes the program simpler.) However, since the loop check is now part
Xof the benchmark, this does have an impact - though a very minor one -
Xon the distribution statistics which have been updated for this
Xversion.
X
X
XIn this section, all changes are described that affect the measurement
Xloop and that are not just renamings of variables. All remarks refer to
Xthe C version; the other language versions have been updated similarly.
X
XIn addition to adding the measurement loop and the printout statements,
Xchanges have been made at the following places:
X
Xo In procedure "main", three statements have been added in the non-
X executed "then" part of the statement
X if (Enum_Loc == Func_1 (Ch_Index, 'C'))
X they are
X strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 3'RD STRING");
X Int_2_Loc = Run_Index;
X Int_Glob = Run_Index;
X The string assignment prevents movement of the preceding assignment
X to Str_2_Loc (5'th statement of "main") out of the measurement loop
X (This probably will not happen for the C version, but it did happen
X with another language and compiler.) The assignment to Int_2_Loc
X prevents value propagation for Int_2_Loc, and the assignment to
X Int_Glob makes the value of Int_Glob possibly dependent from the
X value of Run_Index.
X
Xo In the three arithmetic computations at the end of the measurement
X loop in "main ", the role of some variables has been exchanged, to
X prevent the division from just cancelling out the multiplication as
X it was in [1]. A very smart compiler might have recognized this and
X suppressed code generation for the division.
X
Xo For Proc_2, no code has been changed, but the values of the actual
X parameter have changed due to changes in "main".
X
Xo In Proc_4, the second assignment has been changed from
X Bool_Loc = Bool_Loc | Bool_Glob;
X to
X Bool_Glob = Bool_Loc | Bool_Glob;
X It now assigns a value to a global variable instead of a local
X variable (Bool_Loc); Bool_Loc would be a "dead variable" which is not
X used afterwards.
X
Xo In Func_1, the statement
X Ch_1_Glob = Ch_1_Loc;
X was added in the non-executed "else" part of the "if" statement, to
X prevent the suppression of code generation for the assignment to
X Ch_1_Loc.
X
Xo In Func_2, the second character comparison statement has been changed
X to
X if (Ch_Loc == 'R')
X ('R' instead of 'X') because a comparison with 'X' is implied in the
X preceding "if" statement.
X
X Also in Func_2, the statement
X Int_Glob = Int_Loc;
X has been added in the non-executed part of the last "if" statement,
X in order to prevent Int_Loc from becoming a dead variable.
X
Xo In Func_3, a non-executed "else" part has been added to the "if"
X statement. While the program would not be incorrect without this
X "else" part, it is considered bad programming practice if a function
X can be left without a return value.
X
X To compensate for this change, the (non-executed) "else" part in the
X "if" statement of Proc_3 was removed.
X
XThe distribution statistics have been changed only by the addition of
Xthe measurement loop iteration (1 additional statement, 4 additional
Xlocal integer operands) and by the change in Proc_4 (one operand
Xchanged from local to global). The distribution statistics in the
Xcomment headers have been updated accordingly.
X
X
XThe string operations (string assignment and string comparison) have
Xnot been changed, to keep the program consistent with the original
Xversion.
X
XThere has been some concern that the string operations are over-
Xrepresented in the program, and that execution time is dominated by
Xthese operations. This was true in particular when optimizing
Xcompilers removed too much code in the main part of the program, this
Xshould have been mitigated in version 2.
X
XIt should be noted that this is a language-dependent issue: Dhrystone
Xwas first published in Ada, and with Ada or Pascal semantics, the time
Xspent in the string operations is, at least in all implementations
Xknown to me, considerably smaller. In Ada and Pascal, assignment and
Xcomparison of strings are operators defined in the language, and the
Xupper bounds of the strings occuring in Dhrystone are part of the type
Xinformation known at compilation time. The compilers can therefore
Xgenerate efficient inline code. In C, string assignemt and comparisons
Xare not part of the language, so the string operations must be
Xexpressed in terms of the C library functions "strcpy" and "strcmp".
X(ANSI C allows an implementation to use inline code for these
Xfunctions.) In addition to the overhead caused by additional function
Xcalls, these functions are defined for null-terminated strings where
Xthe length of the strings is not known at compilation time; the
Xfunction has to check every byte for the termination condition (the
Xnull byte).
X
XObviously, a C library which includes efficiently coded "strcpy" and
X"strcmp" functions helps to obtain good Dhrystone results. However, I
Xdon't think that this is unfair since string functions do occur quite
Xfrequently in real programs (editors, command interpreters, etc.). If
Xthe strings functions are implemented efficiently, this helps real
Xprograms as well as benchmark programs.
X
XI admit that the string comparison in Dhrystone terminates later (after
Xscanning 20 characters) than most string comparisons in real programs.
XFor consistency with the original benchmark, I didn't change the
Xprogram despite this weakness.
X
X
XWhen Dhrystone is used, the following "ground rules" apply:
X
Xo Separate compilation (Ada and C versions)
X
X As mentioned in [1], Dhrystone was written to reflect actual
X programming practice in systems programming. The division into
X several compilation units (5 in the Ada version, 2 in the C version)
X is intended, as is the distribution of inter-module and intra-module
X subprogram calls. Although on many systems there will be no
X difference in execution time to a Dhrystone version where all
X compilation units are merged into one file, the rule is that separate
X compilation should be used. The intention is that real programming
X practice, where programs consist of several independently compiled
X units, should be reflected. This also has implies that the compiler,
X while compiling one unit, has no information about the use of
X variables, register allocation etc. occuring in other compilation
X units. Although in real life compilation units will probably be
X larger, the intention is that these effects of separate compilation
X are modeled in Dhrystone.
X
X A few language systems have post-linkage optimization available
X (e.g., final register allocation is performed after linkage). This
X is a borderline case: Post-linkage optimization involves additional
X program preparation time (although not as much as compilation in one
X unit) which may prevent its general use in practical programming. I
X think that since it defeats the intentions given above, it should not
X be used for Dhrystone.
X
X Unfortunately, ISO/ANSI Pascal does not contain language features for
X separate compilation. Although most commercial Pascal compilers
X provide separate compilation in some way, we cannot use it for
X Dhrystone since such a version would not be portable. Therefore, no
X attempt has been made to provide a Pascal version with several
X compilation units.
X
Xo No procedure merging
X
X Although Dhrystone contains some very short procedures where
X execution would benefit from procedure merging (inlining, macro
X expansion of procedures), procedure merging is not to be used. The
X reason is that the percentage of procedure and function calls is part
X of the "Dhrystone distribution" of statements contained in [1]. This
X restriction does not hold for the string functions of the C version
X since ANSI C allows an implementation to use inline code for these
X functions.
X
X
X
Xo Other optimizations are allowed, but they should be indicated
X
X It is often hard to draw an exact line between "normal code
X generation" and "optimization" in compilers: Some compilers perform
X operations by default that are invoked in other compilers only when
X optimization is explicitly requested. Also, we cannot avoid that in
X benchmarking people try to achieve results that look as good as
X possible. Therefore, optimizations performed by compilers - other
X than those listed above - are not forbidden when Dhrystone execution
X times are measured. Dhrystone is not intended to be non-optimizable
X but is intended to be similarly optimizable as normal programs. For
X example, there are several places in Dhrystone where performance
X benefits from optimizations like common subexpression elimination,
X value propagation etc., but normal programs usually also benefit from
X these optimizations. Therefore, no effort was made to artificially
X prevent such optimizations. However, measurement reports should
X indicate which compiler optimization levels have been used, and
X reporting results with different levels of compiler optimization for
X the same hardware is encouraged.
X
Xo Default results are those without "register" declarations (C version)
X
X When Dhrystone results are quoted without additional qualification,
X they should be understood as results obtained without use of the
X "register" attribute. Good compilers should be able to make good use
X of registers even without explicit register declarations ([3], p.
X 193).
X
XOf course, for experimental purposes, post-linkage optimization,
Xprocedure merging and/or compilation in one unit can be done to
Xdetermine their effects. However, Dhrystone numbers obtained under
Xthese conditions should be explicitly marked as such; "normal"
XDhrystone results should be understood as results obtained following
Xthe ground rules listed above.
X
XIn any case, for serious performance evaluation, users are advised to
Xask for code listings and to check them carefully. In this way, when
Xresults for different systems are compared, the reader can get a
Xfeeling how much performance difference is due to compiler optimization
Xand how much is due to hardware speed.
X
X
XThe C version 2.1 of Dhrystone has been developed in cooperation with
XRick Richardson (Tinton Falls, NJ), it incorporates many ideas from the
X"Version 1.1" distributed previously by him over the UNIX network
XUsenet. Through his activity with Usenet, Rick Richardson has made a
Xvery valuable contribution to the dissemination of the benchmark. I
Xalso thank Chaim Benedelac (National Semiconductor), David Ditzel
X(SUN), Earl Killian and John Mashey (MIPS), Alan Smith and Rafael
XSaavedra-Barrera (UC at Berkeley) for their help with comments on
Xearlier versions of the benchmark.
X
X
X[1]
X Reinhold P. Weicker: Dhrystone: A Synthetic Systems Programming
X Benchmark.
X Communications of the ACM 27, 10 (Oct. 1984), 1013-1030
X
X[2]
X Rick Richardson: Dhrystone 1.1 Benchmark Summary (and Program Text)
X Informal Distribution via "Usenet", Last Version Known to me: Sept.
X 21, 1987
X
X[3]
X Brian W. Kernighan and Dennis M. Ritchie: The C Programming
X Language.
X Prentice-Hall, Englewood Cliffs (NJ) 1978
X
X
X
X
X
SHAR_EOF
fi
if test -f 'dhry.h'
then
echo shar: "will not over-write existing file 'dhry.h'"
else
sed 's/^X//' << \SHAR_EOF > 'dhry.h'
X/*
X ****************************************************************************
X *
X * "DHRYSTONE" Benchmark Program
X * -----------------------------
X *
X * Version: C, Version 2.1
X *
X * File: dhry.h (part 1 of 3)
X *
X * Date: May 17, 1988
X *
X * Author: Reinhold P. Weicker
X * Siemens AG, E STE 35
X * Postfach 3240
X * 8520 Erlangen
X * Germany (West)
X * Phone: [xxx-49]-9131-7-20330
X * (8-17 Central European Time)
X * Usenet: ..!mcvax!unido!estevax!weicker
X *
X * Original Version (in Ada) published in
X * "Communications of the ACM" vol. 27., no. 10 (Oct. 1984),
X * pp. 1013 - 1030, together with the statistics
X * on which the distribution of statements etc. is based.
X *
X * In this C version, the following C library functions are used:
X * - strcpy, strcmp (inside the measurement loop)
X * - printf, scanf (outside the measurement loop)
X * In addition, Berkeley UNIX system calls "times ()" or "time ()"
X * are used for execution time measurement. For measurements
X * on other systems, these calls have to be changed.
X *
X * Collection of Results:
X * Reinhold Weicker (address see above) and
X *
X * Rick Richardson
X * PC Research. Inc.
X * 94 Apple Orchard Drive
X * Tinton Falls, NJ 07724
X * Phone: (201) 389-8963 (9-17 EST)
X * Usenet: ...!uunet!pcrat!rick
X *
X * Please send results to Rick Richardson and/or Reinhold Weicker.
X * Complete information should be given on hardware and software used.
X * Hardware information includes: Machine type, CPU, type and size
X * of caches; for microprocessors: clock frequency, memory speed
X * (number of wait states).
X * Software information includes: Compiler (and runtime library)
X * manufacturer and version, compilation switches, OS version.
X * The Operating System version may give an indication about the
X * compiler; Dhrystone itself performs no OS calls in the measurement loop.
X *
X * The complete output generated by the program should be mailed
X * such that at least some checks for correctness can be made.
X *
X ***************************************************************************
X *
X * History: This version C/2.1 has been made for two reasons:
X *
X * 1) There is an obvious need for a common C version of
X * Dhrystone, since C is at present the most popular system
X * programming language for the class of processors
X * (microcomputers, minicomputers) where Dhrystone is used most.
X * There should be, as far as possible, only one C version of
X * Dhrystone such that results can be compared without
X * restrictions. In the past, the C versions distributed
X * by Rick Richardson (Version 1.1) and by Reinhold Weicker
X * had small (though not significant) differences.
X *
X * 2) As far as it is possible without changes to the Dhrystone
X * statistics, optimizing compilers should be prevented from
X * removing significant statements.
X *
X * This C version has been developed in cooperation with
X * Rick Richardson (Tinton Falls, NJ), it incorporates many
X * ideas from the "Version 1.1" distributed previously by
X * him over the UNIX network Usenet.
X * I also thank Chaim Benedelac (National Semiconductor),
X * David Ditzel (SUN), Earl Killian and John Mashey (MIPS),
X * Alan Smith and Rafael Saavedra-Barrera (UC at Berkeley)
X * for their help with comments on earlier versions of the
X * benchmark.
X *
X * Changes: In the initialization part, this version follows mostly
X * Rick Richardson's version distributed via Usenet, not the
X * version distributed earlier via floppy disk by Reinhold Weicker.
X * As a concession to older compilers, names have been made
X * unique within the first 8 characters.
X * Inside the measurement loop, this version follows the
X * version previously distributed by Reinhold Weicker.
X *
X * At several places in the benchmark, code has been added,
X * but within the measurement loop only in branches that
X * are not executed. The intention is that optimizing compilers
X * should be prevented from moving code out of the measurement
X * loop, or from removing code altogether. Since the statements
X * that are executed within the measurement loop have NOT been
X * changed, the numbers defining the "Dhrystone distribution"
X * (distribution of statements, operand types and locality)
X * still hold. Except for sophisticated optimizing compilers,
X * execution times for this version should be the same as
X * for previous versions.
X *
X * Since it has proven difficult to subtract the time for the
X * measurement loop overhead in a correct way, the loop check
X * has been made a part of the benchmark. This does have
X * an impact - though a very minor one - on the distribution
X * statistics which have been updated for this version.
X *
X * All changes within the measurement loop are described
X * and discussed in the companion paper "Rationale for
X * Dhrystone version 2".
X *
X * Because of the self-imposed limitation that the order and
X * distribution of the executed statements should not be
X * changed, there are still cases where optimizing compilers
X * may not generate code for some statements. To a certain
X * degree, this is unavoidable for small synthetic benchmarks.
X * Users of the benchmark are advised to check code listings
X * whether code is generated for all statements of Dhrystone.
X *
X * Version 2.1 is identical to version 2.0 distributed via
X * the UNIX network Usenet in March 1988 except that it corrects
X * some minor deficiencies that were found by users of version 2.0.
X * The following corrections have been made in the C version:
X * - The assignment to Number_Of_Runs was changed
X * - The constant Too_Small_Time was changed
X * - An "else" part was added to the "if" statement in Func_3;
X * for compensation, an "else" part was removed in Proc_3
X * - Shorter file names are used
X *
X ***************************************************************************
X *
X * Defines: The following "Defines" are possible:
X * -DREG=register (default: Not defined)
X * As an approximation to what an average C programmer
X * might do, the "register" storage class is applied
X * (if enabled by -DREG=register)
X * - for local variables, if they are used (dynamically)
X * five or more times
X * - for parameters if they are used (dynamically)
X * six or more times
X * Note that an optimal "register" strategy is
X * compiler-dependent, and that "register" declarations
X * do not necessarily lead to faster execution.
X * -DNOSTRUCTASSIGN (default: Not defined)
X * Define if the C compiler does not support
X * assignment of structures.
X * -DNOENUMS (default: Not defined)
X * Define if the C compiler does not support
X * enumeration types.
X * -DTIMES (default)
X * -DTIME
X * The "times" function of UNIX (returning process times)
X * or the "time" function (returning wallclock time)
X * is used for measurement.
X * For single user machines, "time ()" is adequate. For
X * multi-user machines where you cannot get single-user
X * access, use the "times ()" function. If you have
X * neither, use a stopwatch in the dead of night.
X * "printf"s are provided marking the points "Start Timer"
X * and "Stop Timer". DO NOT use the UNIX "time(1)"
X * command, as this will measure the total time to
X * run this program, which will (erroneously) include
X * the time to allocate storage (malloc) and to perform
X * the initialization.
X * -DHZ=nnn
X * In Berkeley UNIX, the function "times" returns process
X * time in 1/HZ seconds, with HZ = 60 for most systems.
X * CHECK YOUR SYSTEM DESCRIPTION BEFORE YOU JUST APPLY
X * A VALUE.
X *
X ***************************************************************************
X *
X * Compilation model and measurement (IMPORTANT):
X *
X * This C version of Dhrystone consists of three files:
X * - dhry.h (this file, containing global definitions and comments)
X * - dhry_1.c (containing the code corresponding to Ada package Pack_1)
X * - dhry_2.c (containing the code corresponding to Ada package Pack_2)
X *
X * The following "ground rules" apply for measurements:
X * - Separate compilation
X * - No procedure merging
X * - Otherwise, compiler optimizations are allowed but should be indicated
X * - Default results are those without register declarations
X * See the companion paper "Rationale for Dhrystone Version 2" for a more
X * detailed discussion of these ground rules.
X *
X * For 16-Bit processors (e.g. 80186, 80286), times for all compilation
X * models ("small", "medium", "large" etc.) should be given if possible,
X * together with a definition of these models for the compiler system used.
X *
X **************************************************************************
X *
X * Dhrystone (C version) statistics:
X *
X * [Comment from the first distribution, updated for version 2.
X * Note that because of language differences, the numbers are slightly
X * different from the Ada version.]
X *
X * The following program contains statements of a high level programming
X * language (here: C) in a distribution considered representative:
X *
X * assignments 52 (51.0 %)
X * control statements 33 (32.4 %)
X * procedure, function calls 17 (16.7 %)
X *
X * 103 statements are dynamically executed. The program is balanced with
X * respect to the three aspects:
X *
X * - statement type
X * - operand type
X * - operand locality
X * operand global, local, parameter, or constant.
X *
X * The combination of these three aspects is balanced only approximately.
X *
X * 1. Statement Type:
X * ----------------- number
X *
X * V1 = V2 9
X * (incl. V1 = F(..)
X * V = Constant 12
X * Assignment, 7
X * with array element
X * Assignment, 6
X * with record component
X * --
X * 34 34
X *
X * X = Y +|-|"&&"|"|" Z 5
X * X = Y +|-|"==" Constant 6
X * X = X +|- 1 3
X * X = Y *|/ Z 2
X * X = Expression, 1
X * two operators
X * X = Expression, 1
X * three operators
X * --
X * 18 18
X *
X * if .... 14
X * with "else" 7
X * without "else" 7
X * executed 3
X * not executed 4
X * for ... 7 | counted every time
X * while ... 4 | the loop condition
X * do ... while 1 | is evaluated
X * switch ... 1
X * break 1
X * declaration with 1
X * initialization
X * --
X * 34 34
X *
X * P (...) procedure call 11
X * user procedure 10
X * library procedure 1
X * X = F (...)
X * function call 6
X * user function 5
X * library function 1
X * --
X * 17 17
X * ---
X * 103
X *
X * The average number of parameters in procedure or function calls
X * is 1.82 (not counting the function values as implicit parameters).
X *
X *
X * 2. Operators
X * ------------
X * number approximate
X * percentage
X *
X * Arithmetic 32 50.8
X *
X * + 21 33.3
X * - 7 11.1
X * * 3 4.8
X * / (int div) 1 1.6
X *
X * Comparison 27 42.8
X *
X * == 9 14.3
X * /= 4 6.3
X * > 1 1.6
X * < 3 4.8
X * >= 1 1.6
X * <= 9 14.3
X *
X * Logic 4 6.3
X *
X * && (AND-THEN) 1 1.6
X * | (OR) 1 1.6
X * ! (NOT) 2 3.2
X *
X * -- -----
X * 63 100.1
X *
X *
X * 3. Operand Type (counted once per operand reference):
X * ---------------
X * number approximate
X * percentage
X *
X * Integer 175 72.3 %
X * Character 45 18.6 %
X * Pointer 12 5.0 %
X * String30 6 2.5 %
X * Array 2 0.8 %
X * Record 2 0.8 %
X * --- -------
X * 242 100.0 %
X *
X * When there is an access path leading to the final operand (e.g. a record
X * component), only the final data type on the access path is counted.
X *
X *
X * 4. Operand Locality:
X * -------------------
X * number approximate
X * percentage
X *
X * local variable 114 47.1 %
X * global variable 22 9.1 %
X * parameter 45 18.6 %
X * value 23 9.5 %
X * reference 22 9.1 %
X * function result 6 2.5 %
X * constant 55 22.7 %
X * --- -------
X * 242 100.0 %
X *
X *
X * The program does not compute anything meaningful, but it is syntactically
X * and semantically correct. All variables have a value assigned to them
X * before they are used as a source operand.
X *
X * There has been no explicit effort to account for the effects of a
X * cache, or to balance the use of long or short displacements for code or
X * data.
X *
X ***************************************************************************
X */
X
X/* Compiler and system dependent definitions: */
X
X#ifndef TIME
X#ifndef TIMES
X#define TIMES
X#endif
X#endif
X /* Use times(2) time function unless */
X /* explicitly defined otherwise */
X
X#ifdef MSC_CLOCK
X#undef HZ
X#undef TIMES
X#include <time.h>
X#define HZ CLK_TCK
X#endif
X /* Use Microsoft C hi-res clock */
X
X#ifdef TIMES
X#include <sys/types.h>
X#include <sys/times.h>
X /* for "times" */
X#endif
X
X#define Mic_secs_Per_Second 1000000.0
X /* Berkeley UNIX C returns process times in seconds/HZ */
X
X#ifdef NOSTRUCTASSIGN
X#define structassign(d, s) memcpy(&(d), &(s), sizeof(d))
X#else
X#define structassign(d, s) d = s
X#endif
X
X#ifdef NOENUM
X#define Ident_1 0
X#define Ident_2 1
X#define Ident_3 2
X#define Ident_4 3
X#define Ident_5 4
X typedef int Enumeration;
X#else
X typedef enum {Ident_1, Ident_2, Ident_3, Ident_4, Ident_5}
X Enumeration;
X#endif
X /* for boolean and enumeration types in Ada, Pascal */
X
X/* General definitions: */
X
X#include <stdio.h>
X /* for strcpy, strcmp */
X
X#define Null 0
X /* Value of a Null pointer */
X#define true 1
X#define false 0
X
Xtypedef int One_Thirty;
Xtypedef int One_Fifty;
Xtypedef char Capital_Letter;
Xtypedef int Boolean;
Xtypedef char Str_30 [31];
Xtypedef int Arr_1_Dim [50];
Xtypedef int Arr_2_Dim [50] [50];
X
Xtypedef struct record
X {
X struct record *Ptr_Comp;
X Enumeration Discr;
X union {
X struct {
X Enumeration Enum_Comp;
X int Int_Comp;
X char Str_Comp [31];
X } var_1;
X struct {
X Enumeration E_Comp_2;
X char Str_2_Comp [31];
X } var_2;
X struct {
X char Ch_1_Comp;
X char Ch_2_Comp;
X } var_3;
X } variant;
X } Rec_Type, *Rec_Pointer;
X
X
SHAR_EOF
fi
if test -f 'dhry_1.c'
then
echo shar: "will not over-write existing file 'dhry_1.c'"
else
sed 's/^X//' << \SHAR_EOF > 'dhry_1.c'
X/*
X ****************************************************************************
X *
X * "DHRYSTONE" Benchmark Program
X * -----------------------------
X *
X * Version: C, Version 2.1
X *
X * File: dhry_1.c (part 2 of 3)
X *
X * Date: May 17, 1988
X *
X * Author: Reinhold P. Weicker
X *
X ****************************************************************************
X */
X
X#include "dhry.h"
X
X/* Global Variables: */
X
XRec_Pointer Ptr_Glob,
X Next_Ptr_Glob;
Xint Int_Glob;
XBoolean Bool_Glob;
Xchar Ch_1_Glob,
X Ch_2_Glob;
Xint Arr_1_Glob [50];
Xint Arr_2_Glob [50] [50];
X
Xextern char *malloc ();
XEnumeration Func_1 ();
X /* forward declaration necessary since Enumeration may not simply be int */
X
X#ifndef REG
X Boolean Reg = false;
X#define REG
X /* REG becomes defined as empty */
X /* i.e. no register variables */
X#else
X Boolean Reg = true;
X#endif
X
X/* variables for time measurement: */
X
X#ifdef TIMES
Xstruct tms time_info;
Xextern int times ();
X /* see library function "times" */
X#define Too_Small_Time (2*HZ)
X /* Measurements should last at least about 2 seconds */
X#endif
X#ifdef TIME
Xextern long time();
X /* see library function "time" */
X#define Too_Small_Time 2
X /* Measurements should last at least 2 seconds */
X#endif
X#ifdef MSC_CLOCK
Xextern clock_t clock();
X#define Too_Small_Time (2*HZ)
X#endif
X
Xlong Begin_Time,
X End_Time,
X User_Time;
Xfloat Microseconds,
X Dhrystones_Per_Second;
X
X/* end of variables for time measurement */
X
X
Xmain ()
X/*****/
X
X /* main program, corresponds to procedures */
X /* Main and Proc_0 in the Ada version */
X{
X One_Fifty Int_1_Loc;
X REG One_Fifty Int_2_Loc;
X One_Fifty Int_3_Loc;
X REG char Ch_Index;
X Enumeration Enum_Loc;
X Str_30 Str_1_Loc;
X Str_30 Str_2_Loc;
X REG int Run_Index;
X REG int Number_Of_Runs;
X
X /* Initializations */
X
X Next_Ptr_Glob = (Rec_Pointer) malloc (sizeof (Rec_Type));
X Ptr_Glob = (Rec_Pointer) malloc (sizeof (Rec_Type));
X
X Ptr_Glob->Ptr_Comp = Next_Ptr_Glob;
X Ptr_Glob->Discr = Ident_1;
X Ptr_Glob->variant.var_1.Enum_Comp = Ident_3;
X Ptr_Glob->variant.var_1.Int_Comp = 40;
X strcpy (Ptr_Glob->variant.var_1.Str_Comp,
X "DHRYSTONE PROGRAM, SOME STRING");
X strcpy (Str_1_Loc, "DHRYSTONE PROGRAM, 1'ST STRING");
X
X Arr_2_Glob [8][7] = 10;
X /* Was missing in published program. Without this statement, */
X /* Arr_2_Glob [8][7] would have an undefined value. */
X /* Warning: With 16-Bit processors and Number_Of_Runs > 32000, */
X /* overflow may occur for this array element. */
X
X printf ("\n");
X printf ("Dhrystone Benchmark, Version 2.1 (Language: C)\n");
X printf ("\n");
X if (Reg)
X {
X printf ("Program compiled with 'register' attribute\n");
X printf ("\n");
X }
X else
X {
X printf ("Program compiled without 'register' attribute\n");
X printf ("\n");
X }
X printf ("Please give the number of runs through the benchmark: ");
X {
X int n;
X scanf ("%d", &n);
X Number_Of_Runs = n;
X }
X printf ("\n");
X
X printf ("Execution starts, %d runs through Dhrystone\n", Number_Of_Runs);
X
X /***************/
X /* Start timer */
X /***************/
X
X#ifdef TIMES
X times (&time_info);
X Begin_Time = (long) time_info.tms_utime;
X#endif
X#ifdef TIME
X Begin_Time = time ( (long *) 0);
X#endif
X#ifdef MSC_CLOCK
X Begin_Time = clock();
X#endif
X
X for (Run_Index = 1; Run_Index <= Number_Of_Runs; ++Run_Index)
X {
X
X Proc_5();
X Proc_4();
X /* Ch_1_Glob == 'A', Ch_2_Glob == 'B', Bool_Glob == true */
X Int_1_Loc = 2;
X Int_2_Loc = 3;
X strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 2'ND STRING");
X Enum_Loc = Ident_2;
X Bool_Glob = ! Func_2 (Str_1_Loc, Str_2_Loc);
X /* Bool_Glob == 1 */
X while (Int_1_Loc < Int_2_Loc) /* loop body executed once */
X {
X Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;
X /* Int_3_Loc == 7 */
X Proc_7 (Int_1_Loc, Int_2_Loc, &Int_3_Loc);
X /* Int_3_Loc == 7 */
X Int_1_Loc += 1;
X } /* while */
X /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
X Proc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);
X /* Int_Glob == 5 */
X Proc_1 (Ptr_Glob);
X for (Ch_Index = 'A'; Ch_Index <= Ch_2_Glob; ++Ch_Index)
X /* loop body executed twice */
X {
X if (Enum_Loc == Func_1 (Ch_Index, 'C'))
X /* then, not executed */
X {
X Proc_6 (Ident_1, &Enum_Loc);
X strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 3'RD STRING");
X Int_2_Loc = Run_Index;
X Int_Glob = Run_Index;
X }
X }
X /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
X Int_2_Loc = Int_2_Loc * Int_1_Loc;
X Int_1_Loc = Int_2_Loc / Int_3_Loc;
X Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
X /* Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7 */
X Proc_2 (&Int_1_Loc);
X /* Int_1_Loc == 5 */
X
X } /* loop "for Run_Index" */
X
X /**************/
X /* Stop timer */
X /**************/
X
X#ifdef TIMES
X times (&time_info);
X End_Time = (long) time_info.tms_utime;
X#endif
X#ifdef TIME
X End_Time = time ( (long *) 0);
X#endif
X#ifdef MSC_CLOCK
X End_Time = clock();
X#endif
X
X printf ("Execution ends\n");
X printf ("\n");
X printf ("Final values of the variables used in the benchmark:\n");
X printf ("\n");
X printf ("Int_Glob: %d\n", Int_Glob);
X printf (" should be: %d\n", 5);
X printf ("Bool_Glob: %d\n", Bool_Glob);
X printf (" should be: %d\n", 1);
X printf ("Ch_1_Glob: %c\n", Ch_1_Glob);
X printf (" should be: %c\n", 'A');
X printf ("Ch_2_Glob: %c\n", Ch_2_Glob);
X printf (" should be: %c\n", 'B');
X printf ("Arr_1_Glob[8]: %d\n", Arr_1_Glob[8]);
X printf (" should be: %d\n", 7);
X printf ("Arr_2_Glob[8][7]: %d\n", Arr_2_Glob[8][7]);
X printf (" should be: Number_Of_Runs + 10\n");
X printf ("Ptr_Glob->\n");
X printf (" Ptr_Comp: %d\n", (int) Ptr_Glob->Ptr_Comp);
X printf (" should be: (implementation-dependent)\n");
X printf (" Discr: %d\n", Ptr_Glob->Discr);
X printf (" should be: %d\n", 0);
X printf (" Enum_Comp: %d\n", Ptr_Glob->variant.var_1.Enum_Comp);
X printf (" should be: %d\n", 2);
X printf (" Int_Comp: %d\n", Ptr_Glob->variant.var_1.Int_Comp);
X printf (" should be: %d\n", 17);
X printf (" Str_Comp: %s\n", Ptr_Glob->variant.var_1.Str_Comp);
X printf (" should be: DHRYSTONE PROGRAM, SOME STRING\n");
X printf ("Next_Ptr_Glob->\n");
X printf (" Ptr_Comp: %d\n", (int) Next_Ptr_Glob->Ptr_Comp);
X printf (" should be: (implementation-dependent), same as above\n");
X printf (" Discr: %d\n", Next_Ptr_Glob->Discr);
X printf (" should be: %d\n", 0);
X printf (" Enum_Comp: %d\n", Next_Ptr_Glob->variant.var_1.Enum_Comp);
X printf (" should be: %d\n", 1);
X printf (" Int_Comp: %d\n", Next_Ptr_Glob->variant.var_1.Int_Comp);
X printf (" should be: %d\n", 18);
X printf (" Str_Comp: %s\n",
X Next_Ptr_Glob->variant.var_1.Str_Comp);
X printf (" should be: DHRYSTONE PROGRAM, SOME STRING\n");
X printf ("Int_1_Loc: %d\n", Int_1_Loc);
X printf (" should be: %d\n", 5);
X printf ("Int_2_Loc: %d\n", Int_2_Loc);
X printf (" should be: %d\n", 13);
X printf ("Int_3_Loc: %d\n", Int_3_Loc);
X printf (" should be: %d\n", 7);
X printf ("Enum_Loc: %d\n", Enum_Loc);
X printf (" should be: %d\n", 1);
X printf ("Str_1_Loc: %s\n", Str_1_Loc);
X printf (" should be: DHRYSTONE PROGRAM, 1'ST STRING\n");
X printf ("Str_2_Loc: %s\n", Str_2_Loc);
X printf (" should be: DHRYSTONE PROGRAM, 2'ND STRING\n");
X printf ("\n");
X
X User_Time = End_Time - Begin_Time;
X
X if (User_Time < Too_Small_Time)
X {
X printf ("Measured time too small to obtain meaningful results\n");
X printf ("Please increase number of runs\n");
X printf ("\n");
X }
X else
X {
X#ifdef TIME
X Microseconds = (float) User_Time * Mic_secs_Per_Second
X / (float) Number_Of_Runs;
X Dhrystones_Per_Second = (float) Number_Of_Runs / (float) User_Time;
X#else
X Microseconds = (float) User_Time * Mic_secs_Per_Second
X / ((float) HZ * ((float) Number_Of_Runs));
X Dhrystones_Per_Second = ((float) HZ * (float) Number_Of_Runs)
X / (float) User_Time;
X#endif
X printf ("Microseconds for one run through Dhrystone: ");
X printf ("%6.1f \n", Microseconds);
X printf ("Dhrystones per Second: ");
X printf ("%6.1f \n", Dhrystones_Per_Second);
X printf ("\n");
X }
X
X}
X
X
XProc_1 (Ptr_Val_Par)
X/******************/
X
XREG Rec_Pointer Ptr_Val_Par;
X /* executed once */
X{
X REG Rec_Pointer Next_Record = Ptr_Val_Par->Ptr_Comp;
X /* == Ptr_Glob_Next */
X /* Local variable, initialized with Ptr_Val_Par->Ptr_Comp, */
X /* corresponds to "rename" in Ada, "with" in Pascal */
X
X structassign (*Ptr_Val_Par->Ptr_Comp, *Ptr_Glob);
X Ptr_Val_Par->variant.var_1.Int_Comp = 5;
X Next_Record->variant.var_1.Int_Comp
X = Ptr_Val_Par->variant.var_1.Int_Comp;
X Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;
X Proc_3 (&Next_Record->Ptr_Comp);
X /* Ptr_Val_Par->Ptr_Comp->Ptr_Comp
X == Ptr_Glob->Ptr_Comp */
X if (Next_Record->Discr == Ident_1)
X /* then, executed */
X {
X Next_Record->variant.var_1.Int_Comp = 6;
X Proc_6 (Ptr_Val_Par->variant.var_1.Enum_Comp,
X &Next_Record->variant.var_1.Enum_Comp);
X Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;
X Proc_7 (Next_Record->variant.var_1.Int_Comp, 10,
X &Next_Record->variant.var_1.Int_Comp);
X }
X else /* not executed */
X structassign (*Ptr_Val_Par, *Ptr_Val_Par->Ptr_Comp);
X} /* Proc_1 */
X
X
XProc_2 (Int_Par_Ref)
X/******************/
X /* executed once */
X /* *Int_Par_Ref == 1, becomes 4 */
X
XOne_Fifty *Int_Par_Ref;
X{
X One_Fifty Int_Loc;
X Enumeration Enum_Loc;
X
X Int_Loc = *Int_Par_Ref + 10;
X do /* executed once */
X if (Ch_1_Glob == 'A')
X /* then, executed */
X {
X Int_Loc -= 1;
X *Int_Par_Ref = Int_Loc - Int_Glob;
X Enum_Loc = Ident_1;
X } /* if */
X while (Enum_Loc != Ident_1); /* true */
X} /* Proc_2 */
X
X
XProc_3 (Ptr_Ref_Par)
X/******************/
X /* executed once */
X /* Ptr_Ref_Par becomes Ptr_Glob */
X
XRec_Pointer *Ptr_Ref_Par;
X
X{
X if (Ptr_Glob != Null)
X /* then, executed */
X *Ptr_Ref_Par = Ptr_Glob->Ptr_Comp;
X Proc_7 (10, Int_Glob, &Ptr_Glob->variant.var_1.Int_Comp);
X} /* Proc_3 */
X
X
XProc_4 () /* without parameters */
X/*******/
X /* executed once */
X{
X Boolean Bool_Loc;
X
X Bool_Loc = Ch_1_Glob == 'A';
X Bool_Glob = Bool_Loc | Bool_Glob;
X Ch_2_Glob = 'B';
X} /* Proc_4 */
X
X
XProc_5 () /* without parameters */
X/*******/
X /* executed once */
X{
X Ch_1_Glob = 'A';
X Bool_Glob = false;
X} /* Proc_5 */
X
X
X /* Procedure for the assignment of structures, */
X /* if the C compiler doesn't support this feature */
X#ifdef NOSTRUCTASSIGN
Xmemcpy (d, s, l)
Xregister char *d;
Xregister char *s;
Xregister int l;
X{
X while (l--) *d++ = *s++;
X}
X#endif
X
X
SHAR_EOF
fi
if test -f 'dhry_2.c'
then
echo shar: "will not over-write existing file 'dhry_2.c'"
else
sed 's/^X//' << \SHAR_EOF > 'dhry_2.c'
X/*
X ****************************************************************************
X *
X * "DHRYSTONE" Benchmark Program
X * -----------------------------
X *
X * Version: C, Version 2.1
X *
X * File: dhry_2.c (part 3 of 3)
X *
X * Date: May 17, 1988
X *
X * Author: Reinhold P. Weicker
X *
X ****************************************************************************
X */
X
X#include "dhry.h"
X
X#ifndef REG
X#define REG
X /* REG becomes defined as empty */
X /* i.e. no register variables */
X#endif
X
Xextern int Int_Glob;
Xextern char Ch_1_Glob;
X
X
XProc_6 (Enum_Val_Par, Enum_Ref_Par)
X/*********************************/
X /* executed once */
X /* Enum_Val_Par == Ident_3, Enum_Ref_Par becomes Ident_2 */
X
XEnumeration Enum_Val_Par;
XEnumeration *Enum_Ref_Par;
X{
X *Enum_Ref_Par = Enum_Val_Par;
X if (! Func_3 (Enum_Val_Par))
X /* then, not executed */
X *Enum_Ref_Par = Ident_4;
X switch (Enum_Val_Par)
X {
X case Ident_1:
X *Enum_Ref_Par = Ident_1;
X break;
X case Ident_2:
X if (Int_Glob > 100)
X /* then */
X *Enum_Ref_Par = Ident_1;
X else *Enum_Ref_Par = Ident_4;
X break;
X case Ident_3: /* executed */
X *Enum_Ref_Par = Ident_2;
X break;
X case Ident_4: break;
X case Ident_5:
X *Enum_Ref_Par = Ident_3;
X break;
X } /* switch */
X} /* Proc_6 */
X
X
XProc_7 (Int_1_Par_Val, Int_2_Par_Val, Int_Par_Ref)
X/**********************************************/
X /* executed three times */
X /* first call: Int_1_Par_Val == 2, Int_2_Par_Val == 3, */
X /* Int_Par_Ref becomes 7 */
X /* second call: Int_1_Par_Val == 10, Int_2_Par_Val == 5, */
X /* Int_Par_Ref becomes 17 */
X /* third call: Int_1_Par_Val == 6, Int_2_Par_Val == 10, */
X /* Int_Par_Ref becomes 18 */
XOne_Fifty Int_1_Par_Val;
XOne_Fifty Int_2_Par_Val;
XOne_Fifty *Int_Par_Ref;
X{
X One_Fifty Int_Loc;
X
X Int_Loc = Int_1_Par_Val + 2;
X *Int_Par_Ref = Int_2_Par_Val + Int_Loc;
X} /* Proc_7 */
X
X
XProc_8 (Arr_1_Par_Ref, Arr_2_Par_Ref, Int_1_Par_Val, Int_2_Par_Val)
X/*********************************************************************/
X /* executed once */
X /* Int_Par_Val_1 == 3 */
X /* Int_Par_Val_2 == 7 */
XArr_1_Dim Arr_1_Par_Ref;
XArr_2_Dim Arr_2_Par_Ref;
Xint Int_1_Par_Val;
Xint Int_2_Par_Val;
X{
X REG One_Fifty Int_Index;
X REG One_Fifty Int_Loc;
X
X Int_Loc = Int_1_Par_Val + 5;
X Arr_1_Par_Ref [Int_Loc] = Int_2_Par_Val;
X Arr_1_Par_Ref [Int_Loc+1] = Arr_1_Par_Ref [Int_Loc];
X Arr_1_Par_Ref [Int_Loc+30] = Int_Loc;
X for (Int_Index = Int_Loc; Int_Index <= Int_Loc+1; ++Int_Index)
X Arr_2_Par_Ref [Int_Loc] [Int_Index] = Int_Loc;
X Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] += 1;
X Arr_2_Par_Ref [Int_Loc+20] [Int_Loc] = Arr_1_Par_Ref [Int_Loc];
X Int_Glob = 5;
X} /* Proc_8 */
X
X
XEnumeration Func_1 (Ch_1_Par_Val, Ch_2_Par_Val)
X/*************************************************/
X /* executed three times */
X /* first call: Ch_1_Par_Val == 'H', Ch_2_Par_Val == 'R' */
X /* second call: Ch_1_Par_Val == 'A', Ch_2_Par_Val == 'C' */
X /* third call: Ch_1_Par_Val == 'B', Ch_2_Par_Val == 'C' */
X
XCapital_Letter Ch_1_Par_Val;
XCapital_Letter Ch_2_Par_Val;
X{
X Capital_Letter Ch_1_Loc;
X Capital_Letter Ch_2_Loc;
X
X Ch_1_Loc = Ch_1_Par_Val;
X Ch_2_Loc = Ch_1_Loc;
X if (Ch_2_Loc != Ch_2_Par_Val)
X /* then, executed */
X return (Ident_1);
X else /* not executed */
X {
X Ch_1_Glob = Ch_1_Loc;
X return (Ident_2);
X }
X} /* Func_1 */
X
X
XBoolean Func_2 (Str_1_Par_Ref, Str_2_Par_Ref)
X/*************************************************/
X /* executed once */
X /* Str_1_Par_Ref == "DHRYSTONE PROGRAM, 1'ST STRING" */
X /* Str_2_Par_Ref == "DHRYSTONE PROGRAM, 2'ND STRING" */
X
XStr_30 Str_1_Par_Ref;
XStr_30 Str_2_Par_Ref;
X{
X REG One_Thirty Int_Loc;
X Capital_Letter Ch_Loc;
X
X Int_Loc = 2;
X while (Int_Loc <= 2) /* loop body executed once */
X if (Func_1 (Str_1_Par_Ref[Int_Loc],
X Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
X /* then, executed */
X {
X Ch_Loc = 'A';
X Int_Loc += 1;
X } /* if, while */
X if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
X /* then, not executed */
X Int_Loc = 7;
X if (Ch_Loc == 'R')
X /* then, not executed */
X return (true);
X else /* executed */
X {
X if (strcmp (Str_1_Par_Ref, Str_2_Par_Ref) > 0)
X /* then, not executed */
X {
X Int_Loc += 7;
X Int_Glob = Int_Loc;
X return (true);
X }
X else /* executed */
X return (false);
X } /* if Ch_Loc */
X} /* Func_2 */
X
X
XBoolean Func_3 (Enum_Par_Val)
X/***************************/
X /* executed once */
X /* Enum_Par_Val == Ident_3 */
XEnumeration Enum_Par_Val;
X{
X Enumeration Enum_Loc;
X
X Enum_Loc = Enum_Par_Val;
X if (Enum_Loc == Ident_3)
X /* then, executed */
X return (true);
X else /* not executed */
X return (false);
X} /* Func_3 */
X
SHAR_EOF
fi
exit 0
# End of shell archive
